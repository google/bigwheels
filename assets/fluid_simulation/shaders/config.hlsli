// Copyright 2017 Pavel Dobryakov
// Copyright 2022 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

struct Coord
{
    // Texture coordinate.
    float2 xy;

    // Sampling locations based on normalized texture coordinate.
    float2 vUv;
    float2 vL;
    float2 vR;
    float2 vT;
    float2 vB;
};

Coord BaseVS(float2 xy, float2 normalizationScale, float2 texelSize)
{
    Coord coord;
    coord.xy = xy;

    // Sample from the center of the pixel.
    // See https://www.realtimerendering.com/blog/the-center-of-the-pixel-is-0-50-5/
    coord.vUv = xy * normalizationScale + normalizationScale * 0.5;
    coord.vL  = coord.vUv - float2(texelSize.x, 0.0);
    coord.vR  = coord.vUv + float2(texelSize.x, 0.0);
    coord.vT  = coord.vUv + float2(0.0, texelSize.y);
    coord.vB  = coord.vUv - float2(0.0, texelSize.y);
    return coord;
}

Coord BlurVS(float2 xy, float2 normalizationScale, float2 texelSize)
{
    Coord coord;
    coord.xy = xy;

    // Sample from the center of the pixel.
    // See https://www.realtimerendering.com/blog/the-center-of-the-pixel-is-0-50-5/
    coord.vUv    = xy * normalizationScale + normalizationScale * 0.5;
    float offset = 1.33333333;
    coord.vL     = coord.vUv - texelSize * offset;
    coord.vR     = coord.vUv + texelSize * offset;
    return coord;
}

// Scalar inputs for the filter programs. Needs to be 16-bit aligned to be copied
// into a uniform buffer.
//
// NOTE: Fields are organized so that they are packed into 4 word component vectors
// to match the HLSL packing rules (https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules)
//
// This must match the ScalarInputs structure in projects/fluid_simulation/shaders.h.
struct CSInput
{
    float2 texelSize;
    float2 coordinate;

    float4 color;

    float3 curve;
    float  intensity;

    float2 ditherScale;
    float2 dyeTexelSize;

    float threshold;
    float aspectRatio;
    float clearValue;
    float dissipation;

    float dt;
    float radius;
    float weight;
    float curl;

    float2 normalizationScale;
};

ConstantBuffer<CSInput> Params : register(b0);

SamplerState ClampSampler : register(s1);

// Used by bloom*.hlsl, clear.hlsl, copy.hlsl, display.hlsl, splat.hlsl, sunrays*.hlsl.
Texture2D UTexture : register(t2);

// Used by vorticity.hlsl, advection.hlsl, curl.hlsl, divergence.hlsl, gradient_subtract.hlsl.
Texture2D UVelocity : register(t3);

// Used by vorticity.hlsl.
Texture2D UCurl : register(t4);

// Used by advection.hlsl.
Texture2D USource : register(t5);

// Used by display.hlsl.
Texture2D UBloom : register(t6);
Texture2D USunrays : register(t7);
Texture2D UDithering : register(t8);

// Used by gradient_subtract.hlsl, pressure.hlsl.
Texture2D UPressure : register(t9);

// Used by pressure.hlsl.
Texture2D UDivergence : register(t10);

// The output generated by every shader.
RWTexture2D<float4> Output : register(u11);

SamplerState RepeatSampler : register(s12);
